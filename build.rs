use std::{env, fs, path::PathBuf};

use nalgebra::DMatrix;
use rand::rngs::StdRng;
use rand::{Rng, SeedableRng};

use reservoir_datasets::mackey_glass::{MackeyGlass, MackeyGlassParams};

fn main() {
    println!("cargo:rerun-if-changed=build.rs");

    const IN: usize = 1;
    const OUT: usize = 1;
    const N: usize = 64;
    const EXT: usize = 1 + IN + N;

    const LEAKING_RATE: f64 = 0.3;
    const BURN_IN: usize = 5000;
    const WASHOUT: usize = 1000;

    const TRAIN_STEPS: usize = 4000;
    const EVAL_STEPS: usize = 240;
    let ridge_beta: f64 = 1e-6;

    let mut mg = MackeyGlass::new(MackeyGlassParams {
        a: 0.2,
        b: 0.1,
        n: 10,
        tau: 30,
        x0: 1.2,
        h: 0.1,
        steps: BURN_IN + WASHOUT + TRAIN_STEPS + 1,
        seed: Some(42),
        history: None,
    });

    let series_all = mg.generate();
    let series = &series_all[BURN_IN..];

    let mut rng = StdRng::seed_from_u64(12345);

    let mut w_in = vec![0.0f64; N * IN];
    for i in 0..(N * IN) {
        w_in[i] = rng.random::<f64>() * 2.0 - 1.0;
    }

    let density = 0.1;
    let mut w = vec![0.0f64; N * N];
    for r in 0..N {
        for c in 0..N {
            if rng.random::<f64>() < density {
                w[r * N + c] = rng.random::<f64>() * 2.0 - 1.0;
            }
        }
    }

    let rho_est = estimate_spectral_radius(&w, N, 30);
    let target_rho = 0.9;
    let scale = if rho_est > 1e-12 {
        target_rho / rho_est
    } else {
        1.0
    };
    for v in &mut w {
        *v *= scale;
    }

    let mut x = vec![0.0f64; N];

    let t = TRAIN_STEPS;
    let mut xmat = DMatrix::<f64>::zeros(EXT, t);
    let mut ymat = DMatrix::<f64>::zeros(OUT, t);

    for i in 0..WASHOUT {
        let u = series[i];
        step_reservoir(&mut x, u, &w_in, &w, LEAKING_RATE, N);
    }

    for ti in 0..t {
        let idx = WASHOUT + ti;
        let u = series[idx];
        let y_teacher = series[idx + 1];

        xmat[(0, ti)] = 1.0;
        xmat[(1, ti)] = u;
        for i in 0..N {
            xmat[(2 + i, ti)] = x[i];
        }
        ymat[(0, ti)] = y_teacher;

        step_reservoir(&mut x, u, &w_in, &w, LEAKING_RATE, N);
    }

    let xx_t = &xmat * xmat.transpose();
    let mut reg = xx_t.clone();
    for i in 0..EXT {
        reg[(i, i)] += ridge_beta;
    }
    let yx_t = &ymat * xmat.transpose();
    let reg_inv = reg.try_inverse().expect("inverse failed");
    let w_out = yx_t * reg_inv;

    let mut mg2 = MackeyGlass::new(MackeyGlassParams {
        a: 0.2,
        b: 0.1,
        n: 10,
        tau: 30,
        x0: 1.2,
        h: 0.1,
        steps: BURN_IN + EVAL_STEPS + 1,
        seed: Some(999),
        history: None,
    });

    let eval_all = mg2.generate();
    let eval_series = &eval_all[BURN_IN..];

    {
        let mut mn = eval_series[0];
        let mut mx = eval_series[0];
        for &v in &eval_series[..=EVAL_STEPS] {
            mn = mn.min(v);
            mx = mx.max(v);
        }
        println!("cargo:warning=MG eval range (after burn-in): min={:.6} max={:.6}", mn, mx);
    }

    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    let gen_path = out_dir.join("esn_generated.rs");

    let mut s = String::new();
    s.push_str("// @generated by build.rs\n");
    s.push_str("pub type S = f32;\n");
    s.push_str(&format!("pub const IN: usize = {};\n", IN));
    s.push_str(&format!("pub const OUT: usize = {};\n", OUT));
    s.push_str(&format!("pub const N: usize = {};\n", N));
    s.push_str("pub const EXT: usize = 1 + IN + N;\n");
    s.push_str(&format!(
        "pub const LEAKING_RATE: S = {:.8}f32;\n",
        LEAKING_RATE as f32
    ));
    s.push_str(&format!("pub const EVAL_STEPS: usize = {};\n", EVAL_STEPS));

    s.push_str("pub static W_IN_DATA: [S; N * IN] = [\n");
    for i in 0..(N * IN) {
        s.push_str(&format!("{:.8}f32,", w_in[i] as f32));
        if i % 8 == 7 {
            s.push('\n');
        }
    }
    s.push_str("];\n");

    s.push_str("pub static W_DATA: [S; N * N] = [\n");
    for i in 0..(N * N) {
        s.push_str(&format!("{:.8}f32,", w[i] as f32));
        if i % 8 == 7 {
            s.push('\n');
        }
    }
    s.push_str("];\n");

    s.push_str("pub static W_OUT_DATA: [S; OUT * EXT] = [\n");
    for i in 0..(OUT * EXT) {
        let r = i / EXT;
        let c = i % EXT;
        s.push_str(&format!("{:.8}f32,", w_out[(r, c)] as f32));
        if i % 8 == 7 {
            s.push('\n');
        }
    }
    s.push_str("];\n");

    s.push_str("pub static EVAL_U: [S; EVAL_STEPS] = [\n");
    for i in 0..EVAL_STEPS {
        s.push_str(&format!("{:.8}f32,", eval_series[i] as f32));
        if i % 8 == 7 {
            s.push('\n');
        }
    }
    s.push_str("];\n");

    s.push_str("pub static EVAL_TRUTH: [S; EVAL_STEPS] = [\n");
    for i in 0..EVAL_STEPS {
        s.push_str(&format!("{:.8}f32,", eval_series[i + 1] as f32));
        if i % 8 == 7 {
            s.push('\n');
        }
    }
    s.push_str("];\n");

    fs::write(&gen_path, s).unwrap();
}

fn step_reservoir(x: &mut [f64], u: f64, w_in: &[f64], w: &[f64], leak: f64, n: usize) {
    let mut pre = vec![0.0f64; n];

    for r in 0..n {
        let mut acc = 0.0;
        let row = r * n;
        for c in 0..n {
            acc += w[row + c] * x[c];
        }
        pre[r] = acc;
    }

    for r in 0..n {
        pre[r] += w_in[r] * u;
    }

    for r in 0..n {
        let act = pre[r].tanh();
        x[r] = x[r] * (1.0 - leak) + act * leak;
    }
}

fn estimate_spectral_radius(w: &[f64], n: usize, iters: usize) -> f64 {
    let mut rng = StdRng::seed_from_u64(777);
    let mut v = vec![0.0f64; n];
    for i in 0..n {
        v[i] = rng.random::<f64>() * 2.0 - 1.0;
    }
    normalize(&mut v);

    let mut tmp = vec![0.0f64; n];
    for _ in 0..iters {
        matvec(w, &v, &mut tmp, n);
        normalize(&mut tmp);
        v.copy_from_slice(&tmp);
    }
    matvec(w, &v, &mut tmp, n);
    l2(&tmp)
}

fn matvec(w: &[f64], x: &[f64], y: &mut [f64], n: usize) {
    for r in 0..n {
        let row = r * n;
        let mut acc = 0.0;
        for c in 0..n {
            acc += w[row + c] * x[c];
        }
        y[r] = acc;
    }
}

fn l2(v: &[f64]) -> f64 {
    v.iter().map(|x| x * x).sum::<f64>().sqrt()
}

fn normalize(v: &mut [f64]) {
    let n = l2(v);
    let d = if n < 1e-12 { 1.0 } else { n };
    for x in v.iter_mut() {
        *x /= d;
    }
}
